#summary Control Card documentation
#labels Featured,Phase-Design

= Introduction =

This card includes the Control part of Magic-1 it fetches and decodes each instruction to generate signals to control the data path.


= Details =

This card includes the following  parts

|| *Part* || *Description* ||
|| Microcode || It uses the magic-1 opcodes to fetch the microinstruction data from Proms ||
|| Field Decode || Prepare signals delivered from Microcode || 
|| Faults and Interrupts || Stores Interrupt, Fault bits and Encoder signal marshalled to Microcode ||


== Microcode ==

[http://i219.photobucket.com/albums/cc244/leonardoaraujo/Microcode_Schematic.png]

This part will use the following signals:
  * IR
  * ENCODER    
  * Next

As indexes for PROM microinstruction area, so after fetching each microinstruction it will create the 40 bit signals needed for controlling magic-1.

It also handles the branch (jumps in code)

And stores IR signal.

This module is described here:

[http://code.google.com/p/fpga-magic-1/source/browse/trunk/Microcode.vhd]

== Faults and Interrupts ==
[http://i219.photobucket.com/albums/cc244/leonardoaraujo/FaultsInterrupts.png]

== IF(Instruction Fetch) ==
The instruction fetch process will load the instruction from the PROMS using the opcode index.

== Field Decode ==
[http://i219.photobucket.com/albums/cc244/leonardoaraujo/FieldDecode1.png]
[http://i219.photobucket.com/albums/cc244/leonardoaraujo/FieldDecode2.png]
The 
[http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/CompOrg/fetchDecode.html decode] process consist in fetching all the needed operands. For example the {{{ "add.16 (--A),(--B)",IM_NONE,IM_NONE }}} will add the values of A and B registers, then the values of register A and B need to be fetched from Datapath.